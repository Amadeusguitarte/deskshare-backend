<!DOCTYPE html>
<html>

<body>
    <script>
        // DS-CORE ENGINE (The Brain)
        const { ipcRenderer } = require('electron');
        let config = null, currentSid = null, pc = null, res = null;
        let iceSet = new Set();
        let loop = null;

        function log(msg) { console.log(msg); ipcRenderer.send('log', msg); }
        function ui(mode, title, desc) { ipcRenderer.send('update-ui', { mode, title, desc }); }

        ipcRenderer.send('engine-ready');

        ipcRenderer.on('start-engine', (e, d) => {
            config = d.config; res = d.res;
            log(`[CORE] Started for ID: ${config.computerId}`);

            // 1. REGISTER (To unblock Viewer)
            register().then(() => {
                ui('online', 'EN LÍNEA', `ID: ${config.computerId} • Listo`);
                if (loop) clearInterval(loop);
                loop = setInterval(poll, 1500);
                poll();
            });
        });

        async function api(method, endpoint, body = null) {
            return await ipcRenderer.invoke('api-request', { method, endpoint, body });
        }

        async function register() {
            try {
                const r = await api('POST', '/webrtc/register', { computerId: config.computerId, mode: 'native' });
                if (r && r.success) log("Registration Successful.");
            } catch (e) { log("Reg Error: " + e.message); }
        }

        async function poll() {
            if (!config) return;
            try {
                // Check if a session is WAITING for us (created by Viewer)
                const r = await api('GET', "/webrtc/host/pending?computerId=" + config.computerId);

                if (r && r.sessionId) {
                    const sid = r.sessionId;

                    // NEW SESSION DETECTED
                    if (sid !== currentSid) {
                        currentSid = sid;
                        log(`[SYNC] Linked to Session: ${sid}`);
                        ui('linking', 'ENLAZANDO...', 'Sincronizando con Viewer...');

                        const p = await api('GET', "/webrtc/poll/" + sid);
                        if (p && p.offer) {
                            ui('linking', 'NEGOCIANDO...', 'Estableciendo túnel de video...');
                            acceptOffer(p.offer);
                        }
                    } else {
                        // EXISTING SESSION (ICE)
                        if (pc && pc.remoteDescription) {
                            const p = await api('GET', "/webrtc/poll/" + sid);
                            if (p && p.iceCandidates) {
                                for (const c of p.iceCandidates) {
                                    let s = JSON.stringify(c);
                                    if (!iceSet.has(s)) {
                                        iceSet.add(s);
                                        pc.addIceCandidate(new RTCIceCandidate(c)).catch(() => { });
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // No session pending
                    if (!pc) ui('online', 'EN LÍNEA', `ID: ${config.computerId} • Esperando conexión`);
                }
            } catch (e) { }
        }

        async function acceptOffer(remoteOffer) {
            try {
                if (pc) pc.close();
                pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });

                pc.onicecandidate = (e) => {
                    if (e.candidate) api('POST', '/webrtc/ice', { sessionId: currentSid, candidate: e.candidate, isHost: true });
                };

                pc.ondatachannel = (ev) => {
                    ev.channel.onmessage = (e) => {
                        const data = JSON.parse(e.data);
                        if (data.type === 'ping') ev.channel.send(JSON.stringify({ type: 'pong', ts: data.ts }));
                        else ipcRenderer.send('input-event', data);
                    };
                };

                pc.onconnectionstatechange = () => {
                    const s = pc.connectionState;
                    log(`State: ${s}`);
                    if (s === 'connected') ui('connected', 'CONECTADO', 'Transmisión activa');
                    if (s === 'disconnected' || s === 'failed') {
                        ui('online', 'DESCONECTADO', 'Esperando nueva sesión...');
                        pc.close(); pc = null; currentSid = null;
                    }
                };

                const sources = await ipcRenderer.invoke('get-sources');
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: { mandatory: { chromeMediaSource: 'desktop', chromeMediaSourceId: sources[0].id, minFrameRate: 30, maxWidth: res.w, maxHeight: res.h } }
                });

                stream.getTracks().forEach(t => pc.addTrack(t, stream));

                await pc.setRemoteDescription(new RTCSessionDescription(remoteOffer));
                const ans = await pc.createAnswer();
                await pc.setLocalDescription(ans);
                await api('POST', "/webrtc/answer", { sessionId: currentSid, sdp: ans });

            } catch (err) { log('Handshake Error: ' + err.message); }
        }
    </script>
</body>

</html>