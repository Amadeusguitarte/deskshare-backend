<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>DeskShare WebRTC Broadcaster</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0f;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
        }

        #status {
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .status-text {
            font-size: 1.2rem;
            margin: 10px 0;
        }

        .success {
            color: #00ff00;
        }

        .error {
            color: #ff0000;
        }

        .warning {
            color: #ffaa00;
        }
    </style>
</head>

<body>
    <div id="status">
        <div class="status-text" id="statusText">Inicializando...</div>
    </div>

    <script>
        // Configuration (injected by launcher)
        const CONFIG = {
            sessionId: new URLSearchParams(window.location.search).get('sessionId'),
            token: new URLSearchParams(window.location.search).get('token'),
            backendUrl: 'https://deskshare-backend-production.up.railway.app'
        };

        let peerConnection = null;
        let screenStream = null;
        let dataChannel = null;
        let pollInterval = null;

        // Update status UI
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusText');
            statusEl.textContent = message;
            statusEl.className = `status-text ${type}`;
            console.log(`[Broadcaster] ${message}`);
        }

        // Initialize WebRTC peer connection
        function initPeerConnection() {
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(config);

            // Handle ICE candidates
            peerConnection.onicecandidate = async (event) => {
                if (event.candidate) {
                    console.log('[Broadcaster] New ICE candidate');
                    await sendIceCandidate(event.candidate);
                }
            };

            // Connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log('[Broadcaster] Connection state:', peerConnection.connectionState);

                switch (peerConnection.connectionState) {
                    case 'connected':
                        updateStatus('‚úÖ Conectado! Transmitiendo pantalla...', 'success');
                        break;
                    case 'connecting':
                        updateStatus('üîÑ Conectando con viewer...', 'warning');
                        break;
                    case 'failed':
                    case 'disconnected':
                        updateStatus('‚ùå Conexi√≥n perdida', 'error');
                        break;
                }
            };

            // Data channel for receiving input
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                console.log('[Broadcaster] Data channel opened');

                dataChannel.onmessage = (e) => {
                    try {
                        const input = JSON.parse(e.data);
                        handleRemoteInput(input);
                    } catch (err) {
                        console.error('[Broadcaster] Invalid input:', err);
                    }
                };
            };

            return peerConnection;
        }

        // Capture screen using native browser API
        async function captureScreen() {
            try {
                updateStatus('üìπ Solicitando captura de pantalla...', 'warning');

                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: 'always',
                        displaySurface: 'monitor',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30, max: 60 }
                    },
                    audio: false
                });

                updateStatus('‚úÖ Pantalla capturada', 'success');

                // Add tracks to peer connection
                screenStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, screenStream);
                });

                console.log('[Broadcaster] Screen tracks added to peer connection');
                return true;

            } catch (error) {
                updateStatus('‚ùå Error al capturar pantalla: ' + error.message, 'error');
                console.error('[Broadcaster] Screen capture error:', error);
                return false;
            }
        }

        // Send ICE candidate to backend
        async function sendIceCandidate(candidate) {
            try {
                await fetch(`${CONFIG.backendUrl}/api/webrtc/ice`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${CONFIG.token}`
                    },
                    body: JSON.stringify({
                        sessionId: CONFIG.sessionId,
                        candidate,
                        isHost: true
                    })
                });
            } catch (e) {
                console.error('[Broadcaster] Failed to send ICE candidate:', e);
            }
        }

        // Poll for viewer's offer
        async function startSignalingPoll() {
            updateStatus('üîÑ Esperando viewer...', 'warning');

            pollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${CONFIG.backendUrl}/api/webrtc/poll/${CONFIG.sessionId}`, {
                        headers: { 'Authorization': `Bearer ${CONFIG.token}` }
                    });

                    if (!response.ok) {
                        if (response.status === 404) {
                            updateStatus('‚ùå Sesi√≥n cerrada', 'error');
                            stopBroadcasting();
                        }
                        return;
                    }

                    const data = await response.json();

                    // Check for viewer's offer
                    if (data.offer && !peerConnection.remoteDescription) {
                        console.log('[Broadcaster] Received offer from viewer');

                        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));

                        // Create answer
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);

                        // Send answer back
                        await fetch(`${CONFIG.backendUrl}/api/webrtc/answer`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${CONFIG.token}`
                            },
                            body: JSON.stringify({
                                sessionId: CONFIG.sessionId,
                                sdp: answer
                            })
                        });

                        updateStatus('‚úÖ Answer enviado, negociando...', 'success');
                    }

                    // Add ICE candidates from viewer
                    if (data.iceCandidates && data.iceCandidates.length > 0) {
                        for (const candidate of data.iceCandidates) {
                            if (!peerConnection.remoteDescription) continue;
                            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        }
                    }

                } catch (e) {
                    console.error('[Broadcaster] Poll error:', e);
                }
            }, 1000);
        }

        // Handle remote input (mouse/keyboard)
        function handleRemoteInput(input) {
            // This will be handled by sending IPC to main process
            // which will use robotjs or similar to simulate input
            if (window.ipcRenderer) {
                window.ipcRenderer.send('remote-input', input);
            }
        }

        // Stop broadcasting
        function stopBroadcasting() {
            if (pollInterval) {
                clearInterval(pollInterval);
                pollInterval = null;
            }

            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            updateStatus('‚ùå Broadcasting detenido', 'error');
        }

        // Main initialization
        async function init() {
            try {
                if (!CONFIG.sessionId || !CONFIG.token) {
                    updateStatus('‚ùå Configuraci√≥n inv√°lida', 'error');
                    return;
                }

                updateStatus('üöÄ Inicializando WebRTC broadcaster...', 'warning');

                // 1. Initialize peer connection
                initPeerConnection();

                // 2. Capture screen
                const captured = await captureScreen();
                if (!captured) {
                    updateStatus('‚ùå No se pudo capturar pantalla', 'error');
                    return;
                }

                // 3. Start signaling poll
                startSignalingPoll();

                updateStatus('‚úÖ Broadcaster listo, esperando conexi√≥n...', 'success');

            } catch (error) {
                updateStatus('‚ùå Error de inicializaci√≥n: ' + error.message, 'error');
                console.error('[Broadcaster] Init error:', error);
            }
        }

        // Start when page loads
        window.addEventListener('DOMContentLoaded', init);

        // Cleanup on close
        window.addEventListener('beforeunload', stopBroadcasting);
    </script>
</body>

</html>