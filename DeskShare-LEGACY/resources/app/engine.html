<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
</head>

<body>
    <script>
        // v35 ENGINE: DIAGNOSTIC MODE
        // We use direct FS logging to verify life if IPC fails.
        const fs = require('fs');
        const path = require('path');
        const os = require('os');
        const { ipcRenderer } = require('electron');

        const BOOT_LOG = path.join(os.tmpdir(), 'deskshare_engine_boot.txt');
        fs.writeFileSync(BOOT_LOG, `[${new Date().toISOString()}] Engine HTML Loaded\n`);

        function log(msg) {
            try {
                fs.appendFileSync(BOOT_LOG, `[${new Date().toISOString()}] ${msg}\n`);
                console.log(msg);
                ipcRenderer.send('log-stream', msg);
            } catch (e) { }
        }

        window.onerror = function (message, source, lineno, colno, error) {
            log(`CRITICAL ERROR: ${message} at ${lineno}:${colno}`);
        };

        log("Initializing Engine v35...");

        let config = null, currentSid = null, pc = null, res = null;
        let iceSet = new Set();
        let pollInterval = null;

        ipcRenderer.send('engine-ready');
        log('Sent engine-ready IPC');

        ipcRenderer.on('init-engine', (e, d) => {
            log('Received init-engine config!');
            config = d.config; res = d.res;
            log(`[ENGINE] Active ID: ${config.computerId}`);

            if (pc) { pc.close(); pc = null; }
            currentSid = null; iceSet.clear();

            if (pollInterval) clearInterval(pollInterval);
            pollInterval = setInterval(poll, 1500);
            poll();
        });

        async function api(method, endpoint, body = null) {
            log(`API ${method} ${endpoint}`);
            return await ipcRenderer.invoke('api-request', { method, endpoint, body });
        }

        async function poll() {
            if (!config) return;
            try {
                // 1. Check for Pending Sessions
                const r = await api('GET', "/webrtc/host/pending?computerId=" + config.computerId);

                // DATA DIAGNOSIS (v36)
                if (r) {
                    // Only log if we find something interesting or every 10th poll to verify life
                    if (r.sessionId) log(`[RESPONSE] Found Session: ${r.sessionId}`);
                    else if (Math.random() < 0.1) log(`[HEARTBEAT] No pending sessions. Server replied: ${JSON.stringify(r)}`);
                } else {
                    log('[ERROR] API returned NULL (Network/Auth Error?)');
                }

                if (r && r.sessionId) {
                    const sid = r.sessionId;
                    // NEW SESSION DETECTED
                    if (sid !== currentSid || !pc || pc.connectionState === 'failed') {
                        currentSid = sid; iceSet.clear();
                        log(`New Session Found: ${sid}`);

                        const p = await api('GET', "/webrtc/poll/" + sid);
                        if (p && p.offer) {
                            log('Offer Received, Negotiating...');
                            handle(p.offer);
                        }
                    }

                    // HANDLE ICE CANDIDATES
                    if (pc && pc.remoteDescription) {
                        const p = await api('GET', "/webrtc/poll/" + sid);
                        if (p && p.iceCandidates) {
                            for (const c of p.iceCandidates) {
                                let s = JSON.stringify(c);
                                if (!iceSet.has(s)) {
                                    iceSet.add(s);
                                    pc.addIceCandidate(new RTCIceCandidate(c)).catch(() => { });
                                }
                            }
                        }
                    }
                }
            } catch (e) { log('Poll Error: ' + e.message); }
        }

        async function handle(sdp) {
            try {
                if (pc) pc.close();
                log("Starting WebRTC PeerConnection...");
                pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:global.stun.twilio.com:3478' }] });
                pc.onicecandidate = (e) => { if (e.candidate) api('POST', '/webrtc/ice', { sessionId: currentSid, candidate: e.candidate, isHost: true }); };
                pc.ondatachannel = (ev) => {
                    ev.channel.onmessage = (e) => {
                        const data = JSON.parse(e.data);
                        if (data.type === 'ping') ev.channel.send(JSON.stringify({ type: 'pong', ts: data.ts }));
                        else ipcRenderer.send('remote-input', data);
                    };
                };
                pc.onconnectionstatechange = () => {
                    log(`Connection State: ${pc.connectionState}`);
                    ipcRenderer.send('engine-state', pc.connectionState);
                };

                const sources = await ipcRenderer.invoke('get-sources');
                log("Requesting Screen Access...");
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: {
                        mandatory: {
                            chromeMediaSource: 'desktop',
                            chromeMediaSourceId: sources[0].id,
                            minFrameRate: 30, maxWidth: res.w, maxHeight: res.h
                        }
                    }
                });
                log("Screen Access GRANTED!");
                stream.getTracks().forEach(t => pc.addTrack(t, stream));

                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                const ans = await pc.createAnswer();
                await pc.setLocalDescription(ans);
                await api('POST', "/webrtc/answer", { sessionId: currentSid, sdp: ans });

                log('Answer Sent! Waiting for connection...');
            } catch (err) {
                log('CRITICAL ERROR: ' + err.message);
                ipcRenderer.send('log-error', 'Handle Fail: ' + err.message);
            }
        }
    </script>
</body>

</html>