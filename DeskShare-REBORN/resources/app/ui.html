<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&family=JetBrains+Mono&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg: #050507;
            --accent: #3b82f6;
            --success: #10b981;
            --error: #ef4444;
        }

        body {
            background: var(--bg);
            color: #fff;
            font-family: 'Outfit', sans-serif;
            margin: 0;
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            color: var(--accent);
        }

        .status-card {
            background: #121216;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .status-indicator {
            font-size: 1.2rem;
            font-weight: bold;
            color: #555;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .dot {
            width: 12px;
            height: 12px;
            background: #333;
            border-radius: 50%;
        }

        body.online .dot {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        body.online .status-indicator {
            color: var(--success);
        }

        body.connected .dot {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
        }

        body.connected .status-indicator {
            color: var(--accent);
        }

        .log-container {
            flex: 1;
            background: #000;
            border: 1px solid #222;
            border-radius: 8px;
            padding: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            overflow-y: auto;
            color: #888;
        }

        .log-entry {
            margin-bottom: 4px;
            border-bottom: 1px solid #111;
            padding-bottom: 2px;
        }

        .log-entry.info {
            color: #aaa;
        }

        .log-entry.success {
            color: var(--success);
        }

        .log-entry.error {
            color: var(--error);
        }

        .log-entry.net {
            color: #a5b4fc;
        }

        .id-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.7rem;
            color: #444;
            border: 1px solid #222;
            padding: 2px 6px;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>DESKSHARE REBORN</h1>
    </div>

    <div class="status-card">
        <div class="id-badge" id="idBadge">ID: --</div>
        <div class="status-indicator">
            <div class="dot"></div>
            <span id="stLabel">INICIALIZANDO...</span>
        </div>
    </div>

    <div class="log-container" id="logBox">
        <div class="log-entry info">Iniciando motor REBORN v30.0...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        const { ipcRenderer } = require('electron');
        const logBox = document.getElementById('logBox');
        const stLabel = document.getElementById('stLabel');
        const idBadge = document.getElementById('idBadge');

        function log(msg, type = 'info') {
            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            div.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logBox.appendChild(div);
            logBox.scrollTop = logBox.scrollHeight;
        }

        let config = null, pc = null, currentSid = null, res = null;
        let iceSet = new Set();

        ipcRenderer.send('ui-ready');
        ipcRenderer.on('init', (e, data) => {
            config = data.config; res = data.res;
            idBadge.innerText = `ID: ${config.computerId}`;
            document.body.classList.add('online');
            stLabel.innerText = "EN LÍNEA (ESPERANDO)";
            log(`Conectado como Agente ID ${config.computerId}`, 'success');
            startPolling();
        });

        ipcRenderer.on('sync-link', (e, url) => {
            log(`Deep Link recibido: ${url}`, 'net');
            try {
                const params = new URL(url.replace('deskshare://', 'http://localhost/'));
                const token = params.searchParams.get('token');
                const computerId = params.searchParams.get('computerId');
                if (token && computerId) {
                    config = { token, computerId };
                    idBadge.innerText = `ID: ${config.computerId}`;
                    log(`Sincronizado vía link: ID ${computerId}`, 'success');
                }
            } catch (v) { }
        });

        function startPolling() {
            setInterval(async () => {
                if (!config) return;
                try {
                    const url = "https://deskshare-backend-production.up.railway.app/api/webrtc/host/pending?computerId=" + config.computerId;
                    const r = await axios.get(url, { headers: { 'Authorization': 'Bearer ' + config.token } });

                    if (r.data.sessionId) {
                        const sid = r.data.sessionId;
                        if (sid !== currentSid || !pc) {
                            log(`¡Sesión detectada! SID: ${sid.substring(0, 8)}...`, 'net');
                            currentSid = sid; iceSet.clear();
                            await fetchOffer(sid);
                        } else {
                            await fetchIce(sid);
                        }
                    }
                } catch (e) {
                    if (e.response && e.response.status === 401) log("Error: Token inválido", "error");
                }
            }, 1500);
        }

        async function fetchOffer(sid) {
            try {
                const r = await axios.get("https://deskshare-backend-production.up.railway.app/api/webrtc/poll/" + sid, {
                    headers: { 'Authorization': 'Bearer ' + config.token }
                });
                if (r.data.offer) {
                    log("Oferta WebRTC recibida. Negociando...", "info");
                    await handleOffer(r.data.offer);
                }
            } catch (e) { }
        }

        async function fetchIce(sid) {
            if (!pc || !pc.remoteDescription) return;
            try {
                const r = await axios.get("https://deskshare-backend-production.up.railway.app/api/webrtc/poll/" + sid, {
                    headers: { 'Authorization': 'Bearer ' + config.token }
                });
                if (r.data.iceCandidates) {
                    for (const c of r.data.iceCandidates) {
                        let s = JSON.stringify(c);
                        if (!iceSet.has(s)) {
                            iceSet.add(s);
                            await pc.addIceCandidate(new RTCIceCandidate(c));
                        }
                    }
                }
            } catch (e) { }
        }

        async function handleOffer(sdp) {
            try {
                if (pc) pc.close();
                pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:global.stun.twilio.com:3478' }] });

                pc.onicecandidate = (e) => {
                    if (e.candidate) {
                        axios.post("https://deskshare-backend-production.up.railway.app/api/webrtc/ice", {
                            sessionId: currentSid, candidate: e.candidate, isHost: true
                        }, { headers: { 'Authorization': 'Bearer ' + config.token } });
                    }
                };

                pc.ondatachannel = (ev) => {
                    ev.channel.onmessage = (e) => ipcRenderer.send('remote-input', JSON.parse(e.data));
                    ev.channel.onopen = () => log("Canal de datos abierto", "success");
                };

                pc.onconnectionstatechange = () => {
                    log(`Estado de conexión: ${pc.connectionState}`, "info");
                    if (pc.connectionState === 'connected') {
                        document.body.classList.add('connected');
                        stLabel.innerText = "SESIÓN ACTIVA";
                        log("¡CONEXIÓN ESTABLECIDA!", "success");
                    } else if (['failed', 'closed', 'disconnected'].includes(pc.connectionState)) {
                        document.body.classList.remove('connected');
                        stLabel.innerText = "EN LÍNEA (ESPERANDO)";
                        log("Sesión finalizada", "info");
                        currentSid = null;
                    }
                };

                const sources = await ipcRenderer.invoke('get-sources');
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: { mandatory: { chromeMediaSource: 'desktop', chromeMediaSourceId: sources[0].id, minFrameRate: 60, maxWidth: res.w, maxHeight: res.h } }
                });
                stream.getTracks().forEach(t => pc.addTrack(t, stream));

                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                const ans = await pc.createAnswer();
                await pc.setLocalDescription(ans);

                await axios.post("https://deskshare-backend-production.up.railway.app/api/webrtc/answer", {
                    sessionId: currentSid, sdp: ans
                }, { headers: { 'Authorization': 'Bearer ' + config.token } });

                log("Respuesta enviada. Esperando Handshake...", "info");
            } catch (err) { log("Error WebRTC: " + err.message, "error"); }
        }
    </script>
</body>

</html>