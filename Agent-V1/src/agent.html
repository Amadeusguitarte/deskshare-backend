<!DOCTYPE html>
<html>

<head>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            background: transparent;
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
        }

        .card {
            width: 320px;
            height: 440px;
            background: #09090e;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 40px;
            color: white;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            -webkit-app-region: drag;
            position: relative;
            box-shadow: inset 0 0 50px rgba(0, 0, 0, 1);
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 25px;
            display: flex;
            gap: 15px;
            -webkit-app-region: no-drag;
        }

        .btn {
            cursor: pointer;
            color: #333;
            transition: color 0.2s;
            font-size: 20px;
            font-weight: bold;
        }

        .btn:hover {
            color: white;
        }

        .icon-wrapper {
            width: 150px;
            height: 150px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
        }

        .ripple {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 2px solid #10b981;
            opacity: 0;
            animation: ripple-pulse 3s infinite linear;
        }

        .ripple:nth-child(2) {
            animation-delay: 1.5s;
        }

        @keyframes ripple-pulse {
            0% {
                transform: scale(0.6);
                opacity: 0;
            }

            50% {
                opacity: 0.6;
            }

            100% {
                transform: scale(1.4);
                opacity: 0;
            }
        }

        .icon {
            width: 80px;
            height: 80px;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            z-index: 10;
        }

        h2 {
            margin: 0;
            font-size: 19px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
        }

        #sub {
            font-size: 13px;
            color: #555;
            margin-top: 10px;
            font-weight: 300;
        }

        .waiting .icon {
            stroke: #222;
        }

        .waiting .ripple {
            display: none;
        }

        .online .icon {
            stroke: #10b981;
            filter: drop-shadow(0 0 10px #10b981);
        }

        .online .ripple {
            border-color: rgba(16, 185, 129, 0.4);
        }

        .linking .icon {
            stroke: #fbbf24;
            filter: drop-shadow(0 0 15px #fbbf24);
        }

        .linking .ripple {
            border-color: rgba(251, 191, 36, 0.4);
            animation-duration: 1.5s;
        }

        .connected .icon {
            stroke: #3b82f6;
            filter: drop-shadow(0 0 20px #3b82f6);
        }

        .connected .ripple {
            border-color: rgba(59, 130, 246, 0.2);
            animation: none;
            transform: scale(1.2);
            opacity: 0.5;
        }

        .connected h2 {
            color: #fff;
        }

        #localPreview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 68px;
            background: #000;
            border: 2px solid #333;
            border-radius: 8px;
            z-index: 100;
            object-fit: contain;
            display: none;
        }
    </style>
</head>

<body>
    <div id="app" class="card waiting">
        <video id="localPreview" muted autoplay playsinline></video>
        <div class="controls">
            <div class="btn" onclick="window.minimize()">−</div>
            <div class="btn" onclick="window.close()">✕</div>
        </div>
        <div class="icon-wrapper">
            <div class="ripple"></div>
            <div class="ripple"></div>
            <svg class="icon" viewBox="0 0 24 24">
                <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                <line x1="8" y1="21" x2="16" y2="21"></line>
                <line x1="12" y1="17" x2="12" y2="21"></line>
            </svg>
        </div>
        <h2 id="msg">SISTEMA</h2>
        <p id="sub">Iniciando...</p>
        <div id="debugConsole"
            style="width: 280px; height: 100px; background: rgba(0,0,0,0.5); border: 1px solid #333; margin-top: 15px; font-family: monospace; font-size: 10px; color: #0f0; overflow-y: auto; text-align: left; padding: 5px; border-radius: 8px;">
        </div>
    </div>
    <script>
        const { ipcRenderer } = require('electron');
        const app = document.getElementById('app');
        const msg = document.getElementById('msg');
        const sub = document.getElementById('sub');
        const consoleDiv = document.getElementById('debugConsole');

        function log(text) {
            const line = document.createElement('div');
            line.innerText = `> ${text}`;
            consoleDiv.appendChild(line);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        let config = null;
        let pc = null;
        let pollInterval = null;
        const processedCandidates = new Set();

        window.close = () => ipcRenderer.send('app-quit');
        window.minimize = () => ipcRenderer.send('app-minimize');

        ipcRenderer.on('init-config', (e, cfg) => {
            config = cfg;
            log(`Config Loaded. ID: ${config.computerId}`);
            startService();
        });

        async function api(method, path, body) {
            log(`API ${method} ${path}`);
            const res = await ipcRenderer.invoke('api', { method, path, body });
            if (res.error) log(`ERR: ${res.status}`);
            return res;
        }

        // Heartbeat (Production Requirement)
        function setStatus(mode, mText, sText) { app.className = 'card ' + mode; msg.innerText = mText; sub.innerText = sText; }

        async function startService() {
            log('Starting Alpha Service...');
            log(`Token: ${config.token ? config.token.substring(0, 10) + '...' : 'MISSING'}`);

            // HEARTBEAT LOOP (5s for Debug)
            setInterval(async () => {
                try {
                    const r = await api('POST', '/tunnels/heartbeat', { computerId: config.computerId });
                    log(`Heartbeat: ${r.status || 'OK'}`);

                } catch (e) {
                    log(`Heartbeat FAIL: ${e.message}`);
                }
            }, 5000);


            // Immediate First Heartbeat & Registration
            try {
                // v46: REGISTER CAPABILITY (Fixes Parsec UI)
                await api('POST', '/webrtc/register', { computerId: config.computerId, mode: 'native' });

                await api('POST', '/tunnels/heartbeat', { computerId: config.computerId });
                setStatus('online', 'EN LÍNEA', 'Esperando conexión...');
                if (pollInterval) clearInterval(pollInterval);
                pollInterval = setInterval(syncLoop, 2000);
            } catch (e) {
                log(`Startup Failed: ${e.message}`);
            }
        }

        async function syncLoop() {
            if (pc) { pollActiveSession(); return; }
            try {
                const r = await api('GET', '/webrtc/host/pending?computerId=' + config.computerId);
                if (r && r.sessionId) {
                    const p = await api('GET', '/webrtc/poll/' + r.sessionId);
                    if (p && p.offer) {
                        setStatus('linking', 'NEGOCIANDO', 'Estableciendo enlace...');
                        acceptSession(r.sessionId, p.offer, p.userName);
                    }
                }
            } catch (e) { }
        }

        async function pollActiveSession() {
            if (!pc || !pc._sid) return;
            try {
                const data = await api('GET', '/webrtc/poll/' + pc._sid);
                if (data && data.iceCandidates) {
                    data.iceCandidates.forEach(cand => {
                        if (!cand.isHost) {
                            const id = JSON.stringify(cand);
                            if (!processedCandidates.has(id)) {
                                processedCandidates.add(id);
                                log('Rec Remote Cand: ' + cand.candidate.substring(0, 15) + '...');
                                pc.addIceCandidate(new RTCIceCandidate(cand)).catch(() => { });
                            }
                        }
                    });
                }
            } catch (e) { if (e.status === 404) reset(); }
        }

        async function acceptSession(sid, offer, uName) {
            if (pc) return;
            log('Accepting Sess: ' + sid);
            try {
                processedCandidates.clear();
                pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:global.stun.twilio.com:3478' }] });
                pc._sid = sid;

                pc.onicecandidate = (e) => {
                    if (e.candidate) {
                        // log('Found ICE Cand'); // Verbose
                        api('POST', '/webrtc/ice', { sessionId: sid, candidate: e.candidate, isHost: true });
                    }
                };

                pc.onconnectionstatechange = () => {
                    log('Conn State: ' + pc.connectionState);
                    if (pc.connectionState === 'connected') setStatus('connected', 'EN VIVO', `Control: ${uName || 'Web'}`);
                    if (['failed', 'disconnected', 'closed'].includes(pc.connectionState)) reset();
                };

                pc.ondatachannel = (e) => {
                    e.channel.onmessage = (msg) => {
                        try {
                            const d = JSON.parse(msg.data);
                            if (d.type === 'ping') e.channel.send(JSON.stringify({ type: 'pong' }));
                            else ipcRenderer.send('engine-action', d);
                        } catch (err) { }
                    };
                    // CRITICAL HANDSHAKE
                    e.channel.onopen = () => {
                        log('DataChannel Open. Sending Init...');
                        e.channel.send(JSON.stringify({ type: 'init-host', res: { w: 1920, h: 1080 } }));
                    };
                };

                // Get Sources
                const sources = await ipcRenderer.invoke('get-sources');
                if (!sources || sources.length === 0) throw new Error('No Screen Sources Found');

                log(`Selecting Source: ${sources[0].name}`);

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: {
                        mandatory: {
                            chromeMediaSource: 'desktop',
                            chromeMediaSourceId: sources[0].id,
                            minFrameRate: 30, maxFrameRate: 60,
                            maxWidth: 1920, maxHeight: 1080
                        }
                    }
                });

                // Show Local Preview
                const preview = document.getElementById('localPreview');
                if (preview) {
                    preview.srcObject = stream;
                    preview.style.display = 'block';
                }

                stream.getTracks().forEach(t => pc.addTrack(t, stream));

                await pc.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                await api('POST', '/webrtc/answer', { sessionId: sid, sdp: answer });

                log('Answer Sent!', 'success');

            } catch (err) {
                log('AcceptSession Error: ' + err.message, 'error');
                reset();
            }
        }

        function reset() { if (pc) { pc.close(); pc = null; } setStatus('online', 'EN LÍNEA', 'Sesión Privada'); }
        ipcRenderer.send('renderer-ready');
    </script>
</body>

</html>