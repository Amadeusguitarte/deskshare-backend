<!DOCTYPE html>
<html>

<body>
    <script>
        const { ipcRenderer } = require('electron');
        let pc = null;
        let config = null;
        let pollInterval = null;
        let processedCandidates = new Set();

        ipcRenderer.on('init-engine', (e, cfg) => {
            config = cfg;
            startService();
        });

        async function api(method, path, body) {
            return await ipcRenderer.invoke('api', { method, path, body });
        }

        async function startService() {
            try {
                await api('POST', '/webrtc/register', { computerId: config.computerId, mode: 'v1' });
                if (pollInterval) clearInterval(pollInterval);
                pollInterval = setInterval(syncLoop, 1500);
                ipcRenderer.send('engine-status', 'online');
            } catch (e) { ipcRenderer.send('engine-status', { error: 'Error de Red' }); }
        }

        async function syncLoop() {
            if (pc) return; // Stop polling if active session
            try {
                const r = await api('GET', '/webrtc/host/pending?computerId=' + config.computerId);
                if (r && r.sessionId) {
                    const p = await api('GET', '/webrtc/poll/' + r.sessionId);
                    if (p && p.offer) {
                        ipcRenderer.send('engine-status', { mode: 'linking', userName: config.userName });
                        acceptSession(r.sessionId, p.offer);
                    }
                }
            } catch (e) { }
        }

        async function acceptSession(sid, offer) {
            if (pc) return;
            processedCandidates.clear();

            pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });

            pc.onicecandidate = (e) => {
                if (e.candidate) api('POST', '/webrtc/ice', { sessionId: sid, candidate: e.candidate, isHost: true });
            };

            pc.onconnectionstatechange = () => {
                const s = pc.connectionState;
                if (s === 'connected') ipcRenderer.send('engine-status', { mode: 'connected', userName: config.userName });
                if (s === 'failed' || s === 'disconnected') {
                    pc.close(); pc = null;
                    ipcRenderer.send('engine-status', 'online');
                }
            };

            // ACTION CHANNEL
            pc.ondatachannel = (e) => {
                const dc = e.channel;
                dc.onmessage = (msg) => {
                    try { ipcRenderer.send('engine-action', JSON.parse(msg.data)); } catch (err) { }
                };
            };

            // MEDIA CAPTURE
            try {
                const sources = await ipcRenderer.invoke('sources');
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: { mandatory: { chromeMediaSource: 'desktop', chromeMediaSourceId: sources[0].id, maxWidth: 1920, maxHeight: 1080 } }
                });
                stream.getTracks().forEach(t => pc.addTrack(t, stream));
            } catch (e) { ipcRenderer.send('engine-status', { error: 'Error de Captura' }); }

            // ANSWER
            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await api('POST', '/webrtc/answer', { sessionId: sid, sdp: answer });

            // ICE POLLING LOOP (Specific to this session)
            const iceLoop = setInterval(async () => {
                if (!pc || pc.connectionState === 'connected') { clearInterval(iceLoop); return; }
                const data = await api('GET', '/webrtc/poll/' + sid);
                if (data && data.iceCandidates) {
                    data.iceCandidates.forEach(cand => {
                        // v45: ARCHITECTURAL FILTER (Only process candidates from Guest Viewer)
                        if (cand.isHost === false) {
                            const id = JSON.stringify(cand);
                            if (!processedCandidates.has(id)) {
                                processedCandidates.add(id);
                                pc.addIceCandidate(new RTCIceCandidate(cand)).catch(() => { });
                            }
                        }
                    });
                }
            }, 1000);
        }
    </script>
</body>

</html>