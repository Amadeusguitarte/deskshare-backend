<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
</head>

<body>
    <script>
        // ZERO-BASE ENGINE v2.0 (Strict Viewer-Initiated Flow)
        const { ipcRenderer } = require('electron');
        let config = null, currentSid = null, pc = null, res = null;
        let iceSet = new Set();
        let pollInterval = null;

        function log(msg) {
            console.log(msg);
            ipcRenderer.send('log-stream', msg);
        }

        window.onerror = function (message) { log(`CRITICAL ERROR: ${message}`); };

        log("Engine Started (Zero-Base v2.0)");
        ipcRenderer.send('engine-ready');

        ipcRenderer.on('init-engine', (e, d) => {
            config = d.config; res = d.res;
            log(`[SYNC] Active ID: ${config.computerId}`);
            reset();

            // v2.1: REGISTER FIRST (Unblock Viewer)
            register().then(() => {
                pollInterval = setInterval(poll, 1500);
                poll();
            });
        });

        async function register() {
            try {
                log("[INIT] Registering Agent Capabilities...");
                const r = await api('POST', '/webrtc/register', {
                    computerId: config.computerId,
                    mode: 'native' // Identifying as Native Agent
                });
                if (r && r.success) {
                    log("[INIT] Registration Successful. Host is WebRTC Ready.");
                } else {
                    log("[WARN] Registration Warning: " + (r ? r.error : 'Unknown'));
                }
            } catch (e) {
                log("[ERROR] Registration Failed: " + e.message);
            }
        }

        function reset() {
            if (pc) { pc.close(); pc = null; }
            currentSid = null;
            iceSet.clear();
        }

        async function api(method, endpoint, body = null) {
            return await ipcRenderer.invoke('api-request', { method, endpoint, body });
        }

        async function poll() {
            if (!config) return;
            try {
                // 1. DISCOVERY: Find the Session created by the Viewer (via Link)
                const r = await api('GET', "/webrtc/host/pending?computerId=" + config.computerId);

                if (r && r.sessionId) {
                    const sid = r.sessionId;

                    // NEW SESSION DETECTED
                    if (sid !== currentSid) {
                        currentSid = sid;
                        log(`[SYNC] Linked to Session: ${sid}`);

                        // 2. CHECK FOR OFFER (Viewer must have sent it)
                        const p = await api('GET', "/webrtc/poll/" + sid);
                        if (p && p.offer) {
                            log('[HANDSHAKE] Offer Received. Processing...');
                            acceptOffer(p.offer);
                        } else {
                            log('[WAIT] Session found, but waiting for Viewer Offer...');
                        }
                    } else {
                        // EXISTING SESSION - Poll for ICE only
                        if (pc && pc.remoteDescription) {
                            const p = await api('GET', "/webrtc/poll/" + sid);
                            if (p && p.iceCandidates) {
                                for (const c of p.iceCandidates) {
                                    let s = JSON.stringify(c);
                                    if (!iceSet.has(s)) {
                                        iceSet.add(s);
                                        pc.addIceCandidate(new RTCIceCandidate(c)).catch(e => log("ICE Add Fail: " + e.message));
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (e) { log('Poll Error: ' + e.message); }
        }

        async function acceptOffer(remoteOffer) {
            try {
                if (pc) pc.close();
                log("[WEBRTC] Creating PeerConnection...");
                pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:global.stun.twilio.com:3478' }] });

                // ICE HANDLING
                pc.onicecandidate = (e) => {
                    if (e.candidate) {
                        api('POST', '/webrtc/ice', { sessionId: currentSid, candidate: e.candidate, isHost: true });
                        log('[ICE] Sent Candidate');
                    }
                };

                // DATA CHANNELS (Viewer opens them, we answer)
                pc.ondatachannel = (ev) => {
                    const ch = ev.channel;
                    log(`[DATA] Channel Opened: ${ch.label}`);
                    ch.onmessage = (e) => {
                        const data = JSON.parse(e.data);
                        if (data.type === 'ping') ch.send(JSON.stringify({ type: 'pong', ts: data.ts }));
                        else ipcRenderer.send('remote-input', data);
                    };
                };

                pc.onconnectionstatechange = () => {
                    log(`[STATE] ${pc.connectionState.toUpperCase()}`);
                    ipcRenderer.send('engine-state', pc.connectionState);
                };

                // SCREEN CAPTURE
                const sources = await ipcRenderer.invoke('get-sources');
                log("[MEDIA] Capturing Screen...");
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: {
                        mandatory: {
                            chromeMediaSource: 'desktop',
                            chromeMediaSourceId: sources[0].id,
                            minFrameRate: 30, maxWidth: res.w, maxHeight: res.h
                        }
                    }
                });

                stream.getTracks().forEach(t => pc.addTrack(t, stream));
                log("[MEDIA] Stream Added.");

                // HANDSHAKE COMPLETION
                await pc.setRemoteDescription(new RTCSessionDescription(remoteOffer)); // Set Client Offer
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer); // Set Host Answer

                await api('POST', "/webrtc/answer", { sessionId: currentSid, sdp: answer }); // Send Answer
                log('[HANDSHAKE] Answer Sent! Connection should start.');

            } catch (err) {
                log('[ERROR] Handshake Failed: ' + err.message);
                ipcRenderer.send('log-error', err.message);
            }
        }
    </script>
</body>

</html>